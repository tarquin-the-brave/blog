<!doctype html>

<html lang="en">

<head>
  <title>tarquin-the-brave</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="The HTML5 Herald" />
<meta name="author" content="Tom Steavenson" /><meta property="og:title" content="Re-Learning Haskell with Advent of Code - Part 1" />
<meta property="og:description" content="A few years ago I learned myself a Haskell for greater good from a book &ldquo;Learn you a Haskell for greater good&rdquo;1 and the first few chapters of another book &ldquo;Haskell from first principals&rdquo;2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tarquin-the-brave.github.io/blog/posts/re-learning-haskell/" />
<meta property="article:published_time" content="2020-03-29T20:40:05+00:00" />
<meta property="article:modified_time" content="2020-03-29T20:40:05+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Re-Learning Haskell with Advent of Code - Part 1"/>
<meta name="twitter:description" content="A few years ago I learned myself a Haskell for greater good from a book &ldquo;Learn you a Haskell for greater good&rdquo;1 and the first few chapters of another book &ldquo;Haskell from first principals&rdquo;2."/>

<meta name="generator" content="Hugo 0.64.1" />
    

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://tarquin-the-brave.github.io/blog/fontawesome/css/all.min.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://tarquin-the-brave.github.io/blog/css/styles.css" /></head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="https://tarquin-the-brave.github.io/blog/">tarquin-the-brave</a>
            </h1>

      <ul id="social-media">
             <li>
               <a href="https://github.com/tarquin-the-brave" title="GitHub">
               <i class="fab fa-github fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>Some things I think.</em></p>
      
    </header>

    
<nav>
    <ul>
        
    </ul>
</nav>


    <main>




<article>

    <h1>Re-Learning Haskell with Advent of Code - Part 1</h1>

    
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2020-03-29T20:40:05Z">Mar 29, 2020</time>
        </li>
        

        

        <li>19 minutes read</li>
    </ul>
</aside>

    

    
<div class="featured_image">
    <a href="https://tarquin-the-brave.github.io/blog/posts/re-learning-haskell/" title="Re-Learning Haskell with Advent of Code - Part 1">
        <img src="">
    </a>
</div>



    <p>A few years ago I learned myself a Haskell for greater good from a book &ldquo;Learn
you a Haskell for greater good&rdquo;<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> and the first few chapters of another book
&ldquo;Haskell from first principals&rdquo;<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<p>It was fun to learn.  I didn&rsquo;t go onto use Haskell to build any real
applications, beyond coding up some exercises and mini programs to learn
things.</p>
<p>I believe I got a lot from it.  At the very least it&rsquo;s joyful to solve problems
in Haskell.  When I started writing Rust a year later I liked the strong type
system and the features inspired by functional languages: maps, folds, etc.  It
gave me an appreciation of the benefits of immutability and pure functions.  I
believe that&rsquo;s fed into improving how I build things in other languages.</p>
<p>A colleague told me about how they did Advent of Code<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> to learn Rust and a
wider group of colleagues have decided to do a couple of exercises every week,
to learn a variety of languages, and meet fortnightly to discuss approaches.  I
saw this as a good opportunity to &ldquo;pick up Haskell again&rdquo;.  So I did.</p>
<p><em>This post, along with following parts, will be my log of my experiences and
the things I&rsquo;m learning while going through this exercise. It&rsquo;ll be littered
with wild theories, opinions, inefficient uses of code, hopefully some good
learnings, and sometimes things that are just plain wrong.  I&rsquo;m keen to hear
any thoughts people have or anything they can add or ask in comments.  So don&rsquo;t
be afraid to drop a comment or three!</em></p>
<h1 id="week-1">Week 1</h1>
<h2 id="build-tooling">Build Tooling</h2>
<p>First thing&rsquo;s first.  Build tooling.  I didn&rsquo;t really bother with this the last
time around.  I spent most of the time playing in GHCi, the interactive Haskell
terminal, and importing most of the Haskell modules I wrote into that, rather
than compiling and running an executable.</p>
<p>Over the last few years I&rsquo;ve learned: first thing to do after cloning a
codebase: build it! And if you can&rsquo;t rebuilt at the touch of a button, do the
work immediately to make sure you can.  I&rsquo;ve spent time faffing on with linking
issues with C++ applications.  I&rsquo;ve spent time faffing on with Python&rsquo;s
dependency management, or lack thereof<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.  It&rsquo;s not time well spent.  It&rsquo;s
time lost.  I&rsquo;ve been writing Rust at work for about a year and a half.  Rust
has <a href="https://doc.rust-lang.org/cargo/">cargo</a>.  Cargo is phenomenal.  It&rsquo;s a great bit of tooling.  I&rsquo;ll
not lie to you: when facing technical decisions, especially around tooling, I
quite often find myself asking &ldquo;WWCD?&quot;, &ldquo;What Would Cargo Do?&quot;.</p>
<p>I&rsquo;m picking up a language, having build tooling that&rsquo;s rock solid, and
available at the touch of a button is paramount.  So before writing a line of
code, or even reading the first day&rsquo;s challenge, I went looking for build
tooling.</p>
<p>I did a bit of googling with phrases like &ldquo;Haskell toolchain&rdquo;, &ldquo;Haskell build
tools comparison&rdquo;, and found various resources ranging from blog posts to
official documentation.  I found <a href="https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/">this post</a> quite
informative.  It purports to be &ldquo;An opinionated guide&rdquo;.  That&rsquo;s good.
Developers having opinions is good.  Especially when you consider the
alternative: <em>not having thoughts</em>.  It&rsquo;s a long document.  I didn&rsquo;t read
nearly half of it.  But funnily enough the first section in this &ldquo;guide to
Haskell&rdquo;, was on build tooling.  It touched on three options of cabal-install,
stack, and nix, and proceeded to do fairly good job of selling stack.  Combined
with a friend telling me that &ldquo;stack is the closest thing to cargo that Haskell
has got&rdquo;, I was sold on stack, at least for the meantime.  Nix is on my bucket
list, just not today.</p>
<p>So I found and bookmarked the <a href="https://docs.haskellstack.org/en/stable/README/">official documentation</a> and ran
<code>stack new day1</code> to create a project for the problems in &ldquo;day 1&rdquo; of the Advent
of Code.</p>
<h2 id="retracing-the-first-steps">Retracing the first steps</h2>
<p>The problems on <a href="https://adventofcode.com/2019/day/1">day 1</a> involved summing the result of applying a
function to list of integers, and then do the same with a different function.
The halves of this exercise are almost identical except for the function to
apply to each element of the list before summing the results.  This sounds like
an opportunity for function currying.</p>
<p>Using <code>stack new</code> sets up a <code>src/Lib.hs</code> and a <code>app/Main.hs</code>.  While not having
read up on the conventional use of these files, my guess is that <code>Lib.hs</code> is
for any functionality that might become a library, keeping things as generic as
possible, and <code>Main.hs</code> is for code specific to this application: where to read
the data from, error handling, etc.  Although, especially for earlier problems,
this separation will be somewhat artificial.  I&rsquo;m not going to get too worried
about what&rsquo;s in what file, but use it to get used to exporting and importing.</p>
<p>I ended up with a <code>Lib.hs</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">module</span> Lib
    ( <span style="color:#a6e22e">tot_1</span>
    , <span style="color:#a6e22e">tot_2</span>
    ) <span style="color:#66d9ef">where</span>

<span style="color:#a6e22e">f</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integral</span> a <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-&gt;</span> a
<span style="color:#a6e22e">f</span> x <span style="color:#f92672">=</span> x `div` <span style="color:#ae81ff">3</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>

<span style="color:#a6e22e">tot_1</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integral</span> a <span style="color:#f92672">=&gt;</span> [a] <span style="color:#f92672">-&gt;</span> a
<span style="color:#a6e22e">tot_1</span> <span style="color:#f92672">=</span> tot f

<span style="color:#a6e22e">g</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integral</span> a <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-&gt;</span> a
<span style="color:#a6e22e">g</span> x
  <span style="color:#f92672">|</span> f x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">=</span> f x <span style="color:#f92672">+</span> g(f x)
  <span style="color:#f92672">|</span> otherwise <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

<span style="color:#a6e22e">tot_2</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integral</span> a <span style="color:#f92672">=&gt;</span> [a] <span style="color:#f92672">-&gt;</span> a
<span style="color:#a6e22e">tot_2</span> <span style="color:#f92672">=</span> tot g

<span style="color:#a6e22e">tot</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integral</span> a <span style="color:#f92672">=&gt;</span> (a <span style="color:#f92672">-&gt;</span> a) <span style="color:#f92672">-&gt;</span> [a] <span style="color:#f92672">-&gt;</span> a
<span style="color:#a6e22e">tot</span> f <span style="color:#f92672">=</span> sum <span style="color:#f92672">.</span> fmap f
</code></pre></div><p>, and a <code>Main.hs</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">module</span> Main <span style="color:#66d9ef">where</span>

<span style="color:#66d9ef">import</span> Lib
<span style="color:#66d9ef">import</span> Data.List

<span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> ()
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span>
  contents <span style="color:#f92672">&lt;-</span> readFile <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">inputs.txt</span><span style="color:#e6db74">&#34;</span>
  <span style="color:#66d9ef">let</span> inputs <span style="color:#f92672">=</span> fmap read <span style="color:#f92672">.</span> lines <span style="color:#f92672">$</span> contents
  print <span style="color:#f92672">.</span> <span style="color:#66d9ef">Lib</span><span style="color:#f92672">.</span>tot_1 <span style="color:#f92672">$</span> inputs
  print <span style="color:#f92672">.</span> <span style="color:#66d9ef">Lib</span><span style="color:#f92672">.</span>tot_2 <span style="color:#f92672">$</span> inputs
</code></pre></div><p>, having saved the inputs Advent of Code gave me to <code>inputs.txt</code> (each person
gets given their own problem input).</p>
<p>The function <code>tot</code> takes a function and applies it to each element of a list
and sums the results.  To fulfil each half of the problem I then only needed to
define the two functions to pass to <code>tot</code>.</p>
<p>This <a href="https://adventofcode.com/2019/day/1">day 1 problem</a> gave a quick revision of:</p>
<ul>
<li>modules,</li>
<li>do notation,</li>
<li>functions composition (with <code>.</code> &amp; <code>$</code>),</li>
<li>function currying, and</li>
<li>recursion.</li>
</ul>
<p>Recursion ends up featuring heavily in my solutions to the first few days. I&rsquo;m
not sure why, but Haskell make recursion feel like a natural way to solve
problems.  I use recursion in other languages, but it always feels like I&rsquo;ve
done something a bit clever.</p>
<p><a href="https://adventofcode.com/2019/day/2">Day 2</a> asks you to write a basic Intcode computer which is then
extended and used in all odd day problems from day 5 onwards.  I decided to
come back to this and went on to problems from days <a href="https://adventofcode.com/2019/day/3">3</a>, <a href="https://adventofcode.com/2019/day/4">4</a>,
<a href="https://adventofcode.com/2019/day/6">6</a>, and <a href="https://adventofcode.com/2019/day/8">8</a>.</p>
<p><a href="https://adventofcode.com/2019/day/3">Day 3</a> involved drawing lines on a grid and working out where they
cross, <a href="https://github.com/tarquin-the-brave/aoc-19-haskell/tree/master/day3">my solution</a> involved reminding myself of how to make use of:</p>
<ul>
<li>Defining my own types: type constructors, sum types, record syntax,</li>
<li>Generating lists from infinite lists,</li>
<li><code>filter</code>,</li>
<li><code>foldl</code>, and</li>
<li>Using lists as applicative functors,</li>
</ul>
<p>without too much hassle.  <a href="https://github.com/tarquin-the-brave/aoc-19-haskell/tree/master/day3">The solution</a> wasn&rsquo;t very efficient, but
it worked.</p>
<h2 id="fun-with-folds">Fun With Folds</h2>
<p><a href="https://adventofcode.com/2019/day/4">Day 4</a> introduced a simple problem of: work out the number of integers
between two numbers that:</p>
<ul>
<li>Have two adjacent digits that are the same, and</li>
<li>Who&rsquo;s digits never decrease.</li>
</ul>
<p>In <a href="https://github.com/tarquin-the-brave/aoc-19-haskell/tree/master/day4">my solution</a> I used function currying again. A function took a
function that applies a rule between two characters as an argument, and folded
over the digits in the numbers with <code>foldl</code> to apply the rules.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">ruleX</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Char</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Char</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
</code></pre></div><p>In two respects, <code>foldl</code> was an awkward fit:</p>
<ol>
<li>I didn&rsquo;t care about the initial value,</li>
<li>The rules can be confirmed as being broken or obeyed without having to iterate
through every element.</li>
</ol>
<h3 id="no-initial-value">No Initial Value</h3>
<p>The first of these points is equivalent to saying that I don&rsquo;t care about applying
this fold to an empty list.  Using <code>foldl</code>, each time I applied a rule to the
string, I had to provide an initial character that wouldn&rsquo;t cause the rule to
fail in any case.  While I &ldquo;got away with it&rdquo; for this problem, I should find
an alternative pattern to use here to avoid a reasonably crass source of error.</p>
<p>Funnily enough, I had this exact same problem when doing some work in Rust in
the week, and found <a href="https://docs.rs/itertools/0.9.0/itertools/trait.Itertools.html#method.fold1"><code>fold1</code></a> from the <a href="https://docs.rs/itertools/0.9.0/itertools/">itertools
crate</a> with type:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fold1</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">where</span>
    F: FnMut(Self::Item, Self::Item) -&gt; <span style="color:#a6e22e">Self</span>::Item,
    Self: Sized,
</code></pre></div><p>If an empty list has passed in,you get a <code>None</code><sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> back.</p>
<p>Given how much Rust has borrowed from Haskell I was confident this will exist
in Haskell too.</p>
<p>I found <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#v:foldl1"><code>foldl1</code></a> in Prelude.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">foldl1</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Foldable</span> t <span style="color:#f92672">=&gt;</span> (a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a) <span style="color:#f92672">-&gt;</span> t a <span style="color:#f92672">-&gt;</span> a
</code></pre></div><p>It does a fold without needing an initial value but doesn&rsquo;t handle empty lists.</p>
<pre><code>$ stack ghci
...
*Main Lib&gt; :t foldl1
foldl1 :: Foldable t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; a
*Main Lib&gt; foldl1 (+) [1,2,3]
6
*Main Lib&gt; foldl1 (+) []
*** Exception: Prelude.foldl1: empty list
*Main Lib&gt; :q
$
</code></pre><p>I tried searching in <a href="https://hoogle.haskell.org/">Hoogle</a> for a type like the <code>fold1</code> from Rust:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">foldable</span> t <span style="color:#f92672">=&gt;</span> (a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a) <span style="color:#f92672">-&gt;</span> t a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> a
</code></pre></div><p><a href="https://hackage.haskell.org/package/safe-0.3.18/docs/Safe-Foldable.html#v:foldl1May"><code>foldl1May</code></a> looks to be what I want.  I&rsquo;ll keep the <code>safe</code> package
in mind when doing further problems.  Coming from Rust I don&rsquo;t have much of a
taste for these exceptions.</p>
<pre><code>$ stack ghci
...
*Main Lib&gt; :m + Safe.Foldable
*Main Lib Safe.Foldable&gt; :t foldl1May
foldl1May :: Foldable t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; Maybe a
*Main Lib Safe.Foldable&gt; foldl1May (+) []
Nothing
*Main Lib Safe.Foldable&gt; foldl1May (+) [1,2,3]
Just 6
*Main Lib Safe.Foldable&gt; :q
$
</code></pre><p>It&rsquo;s good to know the nomenclature of:</p>
<blockquote>
<p>&ldquo;Safe&rdquo; means: &ldquo;won&rsquo;t throw an exception&rdquo;</p>
</blockquote>
<h3 id="bailing-early-from-a-fold">Bailing Early from a Fold</h3>
<p>The second of these points, where we know the rule is either met or broken
before we&rsquo;ve finished iterating over the digits of the number, basically
means that we&rsquo;d like to quit iterating once we have a solid answer.</p>
<p>In procedural code performing a &ldquo;for loop&rdquo;, a &ldquo;break&rdquo; statement would do
this job.</p>
<p>The way I approached this was to wrap the accumulator in a <code>Maybe</code> and have
the fold function &ldquo;pass through&rdquo; when the accumulator is <code>Nothing</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">foldFunction</span> <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> a) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> a <span style="color:#f92672">-&gt;</span> b <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Maybe</span> a
<span style="color:#a6e22e">foldFunction</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">Nothing</span> <span style="color:#66d9ef">_</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
<span style="color:#a6e22e">foldFunction</span> f (<span style="color:#66d9ef">Just</span> acc) x <span style="color:#f92672">=</span> f acc x
</code></pre></div><p>So as soon as <code>f</code> produces a <code>Nothing</code>, the fold will produce <code>Nothing</code>.</p>
<p>I used <code>Maybe</code> because I didn&rsquo;t care about the data being accumulated, I only
cared whether the fold got to the end of the list.  If I cared about the data
in an &ldquo;early exit&rdquo; of the fold I could have used <code>Either</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">foldFunction&#39;</span> <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> c <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Either</span> a b) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Either</span> a b <span style="color:#f92672">-&gt;</span> c <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Either</span> a b
<span style="color:#a6e22e">foldFunction&#39;</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">Left</span> x <span style="color:#66d9ef">_</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Left</span> x
<span style="color:#a6e22e">foldFunction&#39;</span> f (<span style="color:#66d9ef">Right</span> acc) x <span style="color:#f92672">=</span> f acc x
</code></pre></div><p>I was hoping the compiler would optimise out passing through <code>Nothing</code> and bail
as soon as the accumulator becomes <code>Nothing</code>. Then this pattern could be used
to fold over an infinite list&hellip; sadly not.  Say we want to quit with <code>Nothing</code>
as soon as an element is found greater than <code>10</code>:</p>
<pre><code>*Main Lib&gt; :t foldFunction
foldFunction :: (a -&gt; b -&gt; Maybe a) -&gt; Maybe a -&gt; b -&gt; Maybe a
*Main Lib&gt; foldl (foldFunction (\_ x-&gt; if x &gt; 10 then Nothing else Just x)) (Just 0) [0..10]
Just 10
*Main Lib&gt; foldl (foldFunction (\_ x-&gt; if x &gt; 10 then Nothing else Just x)) (Just 0) [0..11]
Nothing
*Main Lib&gt; foldl (foldFunction (\_ x-&gt; if x &gt; 10 then Nothing else Just x)) (Just 0) [0..]
^CInterrupted.
*Main Lib&gt;
</code></pre><p>UPDATE: I&rsquo;ve been pointed at <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:foldM"><code>foldM</code></a> from <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html"><code>Control.Monad</code></a>.
The above can be written as:</p>
<pre><code>*Main Lib&gt; :m + Control.Monad
*Main Lib Control.Monad&gt; :t foldM
foldM :: (Foldable t, Monad m) =&gt; (b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
*Main Lib Control.Monad&gt; foldM (\_ x -&gt; if x &gt; 10 then Nothing else Just x) 0 [0..10]
Just 10
*Main Lib Control.Monad&gt; foldM (\_ x -&gt; if x &gt; 10 then Nothing else Just x) 0 [0..11]
Nothing
*Main Lib Control.Monad&gt; foldM (\_ x -&gt; if x &gt; 10 then Nothing else Just x) 0 [0..]
Nothing
*Main Lib Control.Monad&gt;
</code></pre><p>Interestingly <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:foldM"><code>foldM</code></a> has this &ldquo;early exit&rdquo;, as you can see it returned
<code>Nothing</code> when ran on the infinite list <code>[0..]</code>.</p>
<p>In my case, I wasn&rsquo;t actually bothered about the accumulator value whether the
fold bailed early or not.  In that case I could have used <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Monad.html#v:foldM_"><code>foldM_</code></a>.</p>
<pre><code>*Main Lib Control.Monad&gt; foldM_ (\_ x -&gt; if x &gt; 10 then Nothing else Just x) 0 [0..10]
Just ()
*Main Lib Control.Monad&gt; foldM_ (\_ x -&gt; if x &gt; 10 then Nothing else Just x) 0 [0..11]
Nothing
*Main Lib Control.Monad&gt; foldM_ (\_ x -&gt; if x &gt; 10 then Nothing else Just x) 0 [0..]
Nothing
*Main Lib Control.Monad&gt;
</code></pre><p>Looking at our <code>foldFunction</code> above, it&rsquo;s actually a reimplementation of <code>&gt;&gt;=</code>
from the <a href="http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-854">implementation of the Monad typeclass for Maybe</a>.</p>
<p>It&rsquo;s interesting that <code>foldM</code> was able to do this &ldquo;early exit&rdquo; but <code>foldl</code>
wasn&rsquo;t.  I&rsquo;ll have to look at the source code and see if I can work out why.</p>
<p>Having a fold that can bail is a powerful pattern when combined with infinite
lists.  I&rsquo;ll remember this one.</p>
<h2 id="trees">Trees</h2>
<p><a href="https://adventofcode.com/2019/day/6">Day 6</a> was all about tree structures.</p>
<p>The problem is presented as: &ldquo;you&rsquo;re given a bunch of data on which planetary bodies
orbit which&rdquo;, with an implication of there being an orbiter and orbitee.  In Physics
this would be the model for when one body is much more massive than the other.
We think of the Moon orbiting the Earth, when really they&rsquo;re a binary pair orbiting
a common centre of mass.  You&rsquo;re then asked to count the total number of direct and
indirect orbits (orbiting something via orbiting something that&rsquo;s orbiting it).
This problem was going to be about finding the data
structure that best describes the overall system and using it.</p>
<p>My first thought was &ldquo;Tree or DAG<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>?&quot;.  A generic Graph could be ruled out as:
C orbiting B, orbiting A, orbiting C, is nonsense. Try and draw it on a piece of
paper.  To decide &ldquo;Tree or DAG&rdquo; I though about if a &ldquo;diamond shape&rdquo; made sense.
I.e. D orbiting C &amp; B, which are both orbiting A.  Trying to draw this on a piece
of paper showed that a &ldquo;diamond shape&rdquo; wouldn&rsquo;t work in general, as in the model,
a body can&rsquo;t orbit two other bodies. Tree it is!</p>
<p>Any number of bodies can be orbiting a body, so we want a tree where a node can
point to any number of subtrees.  <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Tree.html"><code>Data.Tree</code></a> fits the bill.</p>
<p>The input data was a file listing all the orbits.  So for B &amp; C orbiting A, and D
orbiting C the input data would look like:</p>
<pre><code>A)B
A)C
C)D
</code></pre><p><code>)</code> means &ldquo;is orbited by&rdquo; so:</p>
<blockquote>
<p>A is orbited by B.  A is orbited by C. C is orbited by D.</p>
</blockquote>
<p>In the nomenclature of this problem, D is &ldquo;indirectly orbiting&rdquo; A.  A could be the Sun,
B could be Venus, C could be the Earth, D would then be the Moon.</p>
<p>From the giant input I was given, I didn&rsquo;t know whether there was going to be more
than one &ldquo;root&rdquo;/&ldquo;orbital centre&rdquo;, so I&rsquo;d need to use a <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Tree.html#t:Forest">forest</a>, which in
<code>Data.Tree</code> is just a type alias for a list of trees.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Forest</span> a <span style="color:#f92672">=</span> [<span style="color:#66d9ef">Tree</span> a]
</code></pre></div><p>In <a href="https://github.com/tarquin-the-brave/aoc-19-haskell/tree/master/day6">my solution</a> I was able to put the input data into a forest with
<a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Tree.html#v:unfoldForest"><code>unfoldForest</code></a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">unfoldForest</span> <span style="color:#f92672">::</span> (b <span style="color:#f92672">-&gt;</span> (a, [b])) <span style="color:#f92672">-&gt;</span> [b] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Forest</span> a
</code></pre></div><p><code>b</code> is the type of the &ldquo;seed values&rdquo;.  A &ldquo;seed value&rdquo; is a value from which a node
can be generated.  To build the <code>Forest</code>: <code>unfoldForest</code> (and similarly <code>unfoldTree</code>),
take a function that takes a seed value and produces the node data and a list of
seed values for all subtrees from the node. <code>unfoldForest</code> then takes a list of seed
values for the roots of the trees in the forest, whereas <code>unfoldTree</code> take a single
seed value.</p>
<p>I&rsquo;d split the input data into a list of tuples of <code>String</code>s where the first element
of the tuple was the orbitee and the second was the orbiter.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">parseOrbit</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">String</span>)
</code></pre></div><p>In this case, both types <code>a</code> and <code>b</code> in <code>unfoldForest</code> will find the concrete
type of <code>String</code>.  Both the seed value and the node data will just be the name
of the body given in the data.</p>
<p>First I needed to find what the initial seed values, the roots, were in the data.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- Which bodies do not orbit anything?</span>
<span style="color:#a6e22e">roots</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Eq</span> a <span style="color:#f92672">=&gt;</span> [(a,a)] <span style="color:#f92672">-&gt;</span> [a]
<span style="color:#a6e22e">roots</span> orbits <span style="color:#f92672">=</span> [x <span style="color:#f92672">|</span> (x, y) <span style="color:#f92672">&lt;-</span> orbits, notElem x <span style="color:#f92672">.</span> fmap snd <span style="color:#f92672">$</span> orbits]
</code></pre></div><p>Then, given the orbit data, I was able to describe the &ldquo;unfold function&rdquo;.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- Given the orbit data, what orbits a given body?</span>
<span style="color:#a6e22e">forestBuilder</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Eq</span> a <span style="color:#f92672">=&gt;</span> [(a,a)] <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> (a,[a])
<span style="color:#a6e22e">forestBuilder</span> orbits body <span style="color:#f92672">=</span> (body, [snd orbit <span style="color:#f92672">|</span> orbit <span style="color:#f92672">&lt;-</span> orbits, body <span style="color:#f92672">==</span> fst orbit])
</code></pre></div><p><code>forestBuilder orbits</code> would give our &ldquo;unfold function&rdquo;.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">orbits</span> <span style="color:#f92672">::</span> [(<span style="color:#66d9ef">String</span>, <span style="color:#66d9ef">String</span>)]

<span style="color:#a6e22e">unfoldFunction</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">String</span> <span style="color:#f92672">-&gt;</span> (<span style="color:#66d9ef">String</span>, [<span style="color:#66d9ef">String</span>])
<span style="color:#a6e22e">unfoldFunction</span> <span style="color:#f92672">=</span> forestBuilder orbits
</code></pre></div><p>Stringing that together, we can load the input data into a forest:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span>
  contents <span style="color:#f92672">&lt;-</span> fmap lines <span style="color:#f92672">.</span> readFile <span style="color:#f92672">$</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">input.txt</span><span style="color:#e6db74">&#34;</span>
  <span style="color:#66d9ef">let</span> orbits <span style="color:#f92672">=</span> fmap parseOrbit contents
  <span style="color:#66d9ef">let</span> myForest <span style="color:#f92672">=</span> unfoldForest (forestBuilder orbits) (roots orbits)
</code></pre></div><p>Now the data is loaded into a <code>Forest</code>, I want to walk through the forest and
count how many steps from the root each node is.  Summing all those will give
us the number of direct and indirect orbits.</p>
<p>I was hoping to, symmetrically, use <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Tree.html#g:3"><code>foldTree</code></a> to get the answer.</p>
<p>I couldn&rsquo;t see how to do it with <code>foldTree</code>.  I had <code>Tree String</code> where the
string data was wholly uninteresting when counting the number of orbits
as I wanted to sum the depths of each node. The type signature of
<code>foldTree</code> appears to want a function that uses the node values:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">foldTree</span> <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> [b] <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Tree</span> a <span style="color:#f92672">-&gt;</span> b
</code></pre></div><p>I ended up splitting the <code>Tree</code> into its &ldquo;levels&rdquo; with <a href="https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Tree.html#v:levels"><code>levels</code></a>
and then folding over that.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">levels</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Tree</span> a <span style="color:#f92672">-&gt;</span> [[a]]

<span style="color:#a6e22e">sumDepthsTree</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integral</span> b <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Tree</span> a <span style="color:#f92672">-&gt;</span> b
<span style="color:#a6e22e">sumDepthsTree</span> <span style="color:#f92672">=</span> snd <span style="color:#f92672">.</span> foldl foldFunc (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">.</span> levels

<span style="color:#a6e22e">foldFunc</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Integral</span> a <span style="color:#f92672">=&gt;</span> (a,a) <span style="color:#f92672">-&gt;</span> [b] <span style="color:#f92672">-&gt;</span> (a,a)
<span style="color:#a6e22e">foldFunc</span> (depth, acc) x <span style="color:#f92672">=</span> (depth <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, acc <span style="color:#f92672">+</span> depth <span style="color:#f92672">*</span> genericLength x)
</code></pre></div><p>I used a tuple accumulator to record the depth (i.e. the index within <code>levels mytree</code> and the accumulating sum of the depths).</p>
<p>That was enough to give me the answer to the first part of <a href="https://adventofcode.com/2019/day/6">Day 6</a>.  In
writing this I&rsquo;ve just realised there&rsquo;s a second half to the problem that I
missed before which looks like it&rsquo;s asking you to calculate how many steps it
takes to get from one tree node to another.  I&rsquo;ll come back to this at some
point and add to <a href="https://github.com/tarquin-the-brave/aoc-19-haskell/tree/master/day6">my solution</a>.</p>
<h2 id="no-editor-integration-yet">No Editor Integration Yet</h2>
<p>Interestingly, I didn&rsquo;t setup any editor integration for Haskell in this first
week.</p>
<p>While my applications are only being split between <code>src/Lib.hs</code> &amp;
<code>app/Main.hs</code>, and I can search on <a href="https://hoogle.haskell.org/">Hoogle</a>, I&rsquo;ve not felt like I need
it.</p>
<p>The syntax is fairly minimal, so I haven&rsquo;t needed an editor to write code for
me, and it is readable as text.  NeoVim gives me Haskell syntax highlighting
out of the box and I&rsquo;m yet to need any of the IDE level functionality.</p>
<p>I&rsquo;ve blogged before about how <a href="https://tarquin-the-brave.github.io/blog/posts/ide-read-code/">you shouldn&rsquo;t need an IDE to read
code</a> as code should be &ldquo;readable as text&rdquo;, and I&rsquo;m pleased that
Haskell is living up to that.</p>
<p>I&rsquo;ll keep rolling with syntax highlighting and nothing else for now.  If I need
to get some better integration I&rsquo;ll look at installing a Haskell language
server<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup> and hooking NeoVim&rsquo;s <a href="https://github.com/autozimu/LanguageClient-neovim">language server
client</a> to it.</p>
<h2 id="packaging-and-modules">Packaging and Modules</h2>
<p>The simplest way to import functions from a module is to do:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">import</span> Lib
<span style="color:#66d9ef">import</span> Data.Sequence
</code></pre></div><p>This pulls in the functions exported by those modules into the current
namespace.</p>
<p>Importing like this makes code harder to &ldquo;read as text&rdquo; as when you see a
function, where it&rsquo;s come from is not explicit in code.  You&rsquo;d have to look
through what each module you import exports to find the function you&rsquo;re using.</p>
<p>This can be fixed by importing only specific functions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">import</span> Lib (<span style="color:#a6e22e">someFunc</span>)
</code></pre></div><p>Now only the <code>someFunc</code> function will be imported from <code>Lib</code>.</p>
<p>Collisions between functions imported from different libraries and Prelude can
be resolved with qualified imports:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">import</span> quailfied <span style="color:#66d9ef">Lib</span> as <span style="color:#66d9ef">L</span>
</code></pre></div><p>Then every function from <code>Lib</code> is callable as <code>L.someFunc</code>.</p>
<p>These can be combined to do qualified imports and be explicit about the
functions imported:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">import</span> <span style="color:#66d9ef">qualified</span> Lib <span style="color:#66d9ef">as</span> L (someFunc)
</code></pre></div><p>, again resulting in <code>someFunc</code> being callable as <code>L.someFunc</code>.</p>
<p>In order to keep my code as explicit as possible, and thus as &ldquo;readable as
code&rdquo; as possible, I&rsquo;m going to use this as a convention from now on.  I&rsquo;ll
also try to read some open source Haskell to see if the wider community has a
convention on this.</p>
<p>This may end up being laborious.  In Rust, importing is <em>explicit</em> in this way,
but a large amount of functionality is held in methods implemented on
structures and in traits.  You only have to import the <code>struct</code> or <code>trait</code> to
get the methods. In Haskell, as everything is a function, I&rsquo;ll need to import
each function explicitly.</p>
<p>If I end up giving up on this as a convention I&rsquo;ll look into integrating a
Haskell language server<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup> into my editor to give me the &ldquo;go to definition&rdquo;
and all those goodies.</p>
<h2 id="summary">Summary</h2>
<p>Doing some of the first few <a href="https://adventofcode.com/">Advent of Code</a> problems was good for
revising and refining some of the basics.  I reckon I could churn through all
of the problems using the basic tools I know how to use: list manipulation,
recursion, functors, applicative functors, etc.  But, I want to go away and do
some wider reading before continuing so I can really level up my Haskell.</p>
<p>My general feelings about Haskell thus far, learning it for the second time:</p>
<ul>
<li>I&rsquo;m enjoying the purity and clean syntax.</li>
<li>I&rsquo;m enjoying using the word &ldquo;function&rdquo; without feeling a little guilty.</li>
<li>Compared to Rust, Haskell is more implicit.  It appears there&rsquo;s ways of being
of being totally explicit about things and I&rsquo;ll look to do that.  Maybe with
a bit more experience I&rsquo;ll relax a little bit.</li>
<li>I haven&rsquo;t fully learned how the packaging works yet, I&rsquo;ll feel more
comfortable when I have.  One thing I don&rsquo;t know is how you find out what
&ldquo;package&rdquo; a module is found in.</li>
<li>It seems to be the way to search for &ldquo;I need a thing that does this&rdquo; is to
know what type signature you&rsquo;re looking for is, and type that into the search
bar on <a href="https://hoogle.haskell.org/">Hoogle</a>.</li>
<li>There seems to be a lot of different ways to do the same thing, and I&rsquo;m not
sure yet where to find advice on what good approaches are.</li>
</ul>
<p>I&rsquo;ll go do some reading, then come back to these problems.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Learn you a Haskell for greater good. <a href="http://learnyouahaskell.com/chapters">http://learnyouahaskell.com/chapters</a> <a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Haskell from first principals. <a href="https://haskellbook.com/">https://haskellbook.com/</a> <a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>Advent of code provided a coding challenge on each day of December. <a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p><a href="https://python-poetry.org/">Poetry</a> does quite a good job of Python dependency management.
It&rsquo;s not totally watertight, but it&rsquo;s a huge improvement on <a href="https://pypi.org/project/pip/">pip</a> &amp; <a href="https://pipenv-fork.readthedocs.io/en/latest/">Pipenv</a>
to which my derision is directed.  And Poetry has a very pretty website. <a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>Rust&rsquo;s <code>Option&lt;T&gt;</code> (with variants <code>Some&lt;T&gt;</code> &amp; <code>None</code>) enum is equivalent to Haskell&rsquo;s <code>Maybe T</code>
with <code>Just T</code> and <code>Nothing</code>. <a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>DAG: Direct Acyclic Graph: <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">https://en.wikipedia.org/wiki/Directed_acyclic_graph</a> <a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p>I&rsquo;ve found <a href="https://github.com/haskell/haskell-language-server">Haskell language server</a>, but as the README says, it&rsquo;s in &ldquo;early stages&rdquo;. <a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://tarquin-the-brave.github.io/blog/posts/iterttools/"><i class="fa fa-chevron-circle-left"></i> Itertools - A Force for Good?</a>
        </li>
        
        
    </ul>
</section>
    
        <section id="utterances"></section>

<script>
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        let s = document.createElement("script");
        s.setAttribute("repo", "tarquin-the-brave\/blog");
        s.src = "https://utteranc.es/client.js";
        
          s.setAttribute("issue-term", "pathname");
        
        
        document.getElementById("utterances").innerHTML = "";
        document.getElementById("utterances").appendChild(s);
    } else {
        let s = document.createElement("script");
        s.setAttribute("repo", "tarquin-the-brave\/blog");
        s.src = "https://utteranc.es/client.js";
        
          s.setAttribute("issue-term", "pathname");
        
        
        document.getElementById("utterances").innerHTML = "";
        document.getElementById("utterances").appendChild(s);
    }
</script>

    
    





</main>
    <footer>
        <h6>Copyright © 2020 - Tom Steavenson |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://tarquin-the-brave.github.io/blog/index.xml">Subscribe </a></h6>
    </footer>
</div>
<script src="https://tarquin-the-brave.github.io/blog/js/scripts.js"></script>

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-161243400-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>

</html>

